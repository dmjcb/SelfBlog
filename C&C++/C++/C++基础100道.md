# C++基础知识面试题总结

## 1、多态的实现

## 2、说说C/C++的区别

## 3、const关键字

## 4、malloc/free 和 new/delete区别

## 5、指针和引用的区别

## 6、C++中堆和栈的区别

## 7、关键字static

## 8、在C++程序中调用被C语言修饰的函数,为什么要加extern "C"

> 解决函数名在符号表中的匹配问题, 实现C++与C的混合编程


如果不加会出现连接错误(XX函数未定义), 因为C++语言和C语言对编译后的函数符号和外部变量符号的修饰方式不一样

代码编译过后, 连接器解析外部符号的时候就会出现无法解析外部符号的错误

加上extern "C"之后,C++编译器就会按照C语言的符号修饰规则对函数进行修饰, 连接器就能够正确解析

## extern

extern 是 C/C++ 语言中表明函数和全局变量作用范围(可见性)的关键字,该关键字告诉编译器,其声明的函数和变量可以在本模块或其它模块中使用

extern "C"是连接申明(linkage declaration),被extern "C"修饰的变量和函数是按照C语言方式编译和连接的

## C++中对类C函数编译

C++支持函数重载, C语言不支持, 函数被C++编译后在符号库中的名字与C语言中的不同

```c
void func(int x, int y)
```

C语言编译器编译后在符号库中名字为_func

C++编译器符号库中名字则会类似_func_int_int, 包含了函数名、函数参数数量及类型信息, C++就是靠这种机制来实现函数重载

## 9、如何防止头文件被重复包含

> 头文件开头结尾添加条件编译宏

```c
#ifndef INCLUDE_HEADER_H
#define INCLUDE_HEADER_H

程序段

#endif
```

如果宏INCLUDE_HEADER_H未定义, 则定义INCLUDE_HEADER_H宏, 并编译程序段

## 10、什么是内存泄漏? 什么是野指针? 什么是内存越界? 如何避免? 

### 内存泄漏

内存泄漏是应用程序分配某段内存后,由于设计错误,导致在释放该段内存之前就失去了对该段内存的控制,从而造成了内存的浪费

### 野指针

指向不可用内存区域的指针

11、描述一下封装、继承、多态

12、堆栈缓存方式的区别

13、STL容器有哪些,常用的算法

## 14、什么是面向对象

### 面向对象

首先抽象出各种对象(各种类), 把数据和方法都封装在对象中(类), 然后各个对象之间发生相互作用

### 面向过程

将问题分解成若干步骤(动作), 每个步骤(动作)用一个函数来实现, 在使用时将数据传递给这些函数

15、用过的设计模式,简单举几个例子

16、如何理解智能指针,什么时候改变引用计数

## 17、share_ptr与weak_ptr的区别与联系


### share_ptr

智能指针主要用于管理在堆上分配的内存,它将普通的指针封装为一个栈对

当栈对象的生存周期结束后,会在析构函数中释放掉申请的内存,从而防止内存泄漏

shared_ptr采用引用计数的方法,记录当前内存资源被多少个智能指针引用

该引用计数的内存在堆上分配

当新增一个时引用计数加1,当过期时引用计数减一

只有引用计数为0时,智能指针才会自动释放引用的内存资源

### weak_ptr

share_ptr虽然已经很好用了,但是有一点share_ptr智能指针还是有内存泄露的情况,当两个对象相互使用一个shared_ptr成员变量指向对方,会造成循环引用,使引用计数失效,从而导致内存泄漏

weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象

进行该对象的内存管理的是那个强引用的shared_ptr, weak_ptr只是提供了对管理对象的一个访问手段

18、表述下string的Copy-On-Write技术,写时copy

19、描述下C++的浅copy,深copy,写时copy和引用计数的copy

20、C++构造函数是否可以抛出异常

21、是否在析构函数抛出异常

22、构造函数中,成员变量一定要通过初始化列表来初始化的

23、volatile的作用

24、构造函数和析构函数可以调用虚函数吗

25、内存对齐的原则

26、内联函数有什么优点？内联函数和宏定义的区别

27、数组与指针的区别与联系,函数指针,指针函数,指针数组,数组指针

28、STL set 和 map都是基于什么实现的

29、常见的内存错误及其对策

## 30、三种内存对象的比较

### 栈对象

栈对象的优势是在适当的时候自动生成.又在适当的时候自动销毁.不需要程序员操心;

栈对象的创建速度一般较堆对象快.因为分配堆对象时.会调用operator new操作.operator new会采用某种内存空间搜索算法.而该搜索过程可能是很费时间

产生栈对象仅需要移动栈顶指针就可

栈空间容量比较小.一般是1MB～2MB.体积比较大的对象不适合在栈中分配

递归函数中最好不要使用栈对象.因为随着递归调用深度的增加.所需的栈空间也会线性增加.当所需栈空间不够时.便会导致栈溢出错误

### 堆对象

产生时刻和销毁时刻都要程序员精确定义.程序员对堆对象的生命具有完全的控制权

需要创建一个对象能够被多个函数所访问.但是又不想使其成为全局.那么这个时候创建一个堆对象无疑是良好的选择.然后在各个函数之间传递这个堆对象的指针.便可以实现对该对象的共享

相比于栈空间.堆的容量要大得多

当物理内存不够时.如果这时还需要生成新的堆对象.通常不会产生运行时错误.而是系统会使用虚拟内存来扩展实际的物理内存

### 静态对象

- 全局对象

全局对象为类间通信和函数间通信提供了一种最简单的方式.虽然这种方式并不优雅

全局对象意味着不安全和高耦合.在程序中过多地使用全局对象将大大降低程序的健壮性、稳定性、可维护性和可复用性

- 类的静态成员

上面已经提到.基类及其派生类的所有对象都共享这个静态成员对象.所以当需要在这些class之间或这些class objects之间进行数据共享或通信时.这样的静态成员无疑是很好的选择. 

- 静态局部对象

主要可用于保存该对象所在函数被屡次调用期间的中间状态.最显著的例子就是递归函数.我们都知道递归函数是自己调用自己的函数.如果在递归函数中定义一个nonstatic局部对象.那么当递归次数相当大时.所产生的开销也是巨大的. 这是因为nonstatic局部对象是栈对象.每递归调用一次.就会产生一个这样的对象.每返回一次.就会释放这个对象.而且.这样的对象只局限于当前调用层.对于更深入的嵌套层和更浅露的外层.都是不可见的. 每个层都有自己的局部对象和参数. 

在递归函数设计中.可以使用static对象替代nonstatic局部对象(即栈对象).这不仅可以减少每次递归调用和返回时产生和释放nonstatic对象的开销.而且static对象还可以保存递归调用的中间状态.并且可为各个调用层所访问

31、C++内存泄露及检测工具

32、什么时候要用虚析构函数

33、#include<a.h> 与#include"a.h"的区别

34、什么是RTTI (Run-time type identification)

35、引用作为函数参数有哪些特点

36、在什么时候需要使用常引用

37、将引用作为函数返回值类型的格式、好处和需要遵守的规则

38、结构体和联合体的区别

39、重载和重写的区别

40、栈内存与文字常量区

41、struct和class的区别

42、如何判断浮点数是否相等,LONG呢

43、不允许重载的5个运算符

44、拷贝构造函数在哪几种情况下会被调用

45、什么时候必须重写拷贝构造函数

46、静态成员函数存在的意义

47、流运算符为什么不能通过类的成员函数重载

48、当一个类中没有任何成员变量和成员函数,这时sizeof(A)的A值是多少,

49、如果不是零,请解释一下编译器为什么没有让他为零

50、多态的作用

## 51、什么函数不能声明为虚函数

> 构造函数

## 52、系统会自动和关闭的3个标准的文件是

标准输入流, stdin

标准输出流, stdout

标准错误输出流, stderr

53、说出字符常量和字符串常量的区别,并使用sizeof 计算有什么不同

54、Windows消息系统由哪几部分构成

55、assert()的作用

56、Windows的消息机制

57、SendMessage和PostMessage的区别

58、Dll和lib的区别

59、多线程如何实现通讯,如何进行同步

60、stl实现了那些排序算法

61、一元、二元仿函数的区别和使用背景

62、智能指针可以放到容器中么

63、请简述Windows内存管理的方式

64、strcpy和memcpy使用时的注意事项,strncpy、memncpy的区别

65、const和static能同时修饰成员函数吗

66、何时编译器会自动生成默认构造函数

67、何时编译器会自动生成拷贝构造函数

68、动态链接库和静态链接库的区别

69、描述一下函数调用的整个过程

70、C++ STL vector的实现机制

71、面向对象是一种思想,如何使用C语言来实现

72、C++有哪些数据类型, 为什么long和int都是4字节

73、Java和C++的区别是什么,分别用在什么场景比较好

74、函数调用类型_cedecl,_stdcall,_fastcall

75、什么是序列化和反序列化

76、用预处理指令声明一个常数, 用以表明1年终有多少秒

77、strtok函数在使用上要注意什么问题

78、char * const p ,char const * p,  char const * const p区别

79、介绍一下右值引用和移动语义和完美转发

80、说说你使用的C++11的特性

## 81、如何区分左值和右值

> 左值与右值的根本区别在于能否获取内存地址

### 左值与右值

- 左值指既能够出现在等号左边, 也能出现在等号右边的变量

- 右值则是只能出现在等号右边的变量

左值在内存有确定存储地址、有变量名.表达式结束依然存在的值.简单来说左值就是非临时对象

右值就是在内存没有确定存储地址、没有变量名.表达式结束就会销毁的值.简单来说右值就是临时对象

### 左值引用

### 右值引用


#### 参考资料

[【Modern C++】深入理解左值、右值](https://mp.weixin.qq.com/s/_9-0iNUw6KHTF3a-vSMCmg)

[理解 C/C++ 中的左值和右值](https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/)

[C++中左值(引用)及右值(引用)详解](https://blog.csdn.net/weixin_43064827/article/details/120803409?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120803409-blog-78619152.pc_relevant_aa_2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120803409-blog-78619152.pc_relevant_aa_2&utm_relevant_index=1)


82、为什么C++访问虚函数比访问普通函数慢

83、为什么需要纯虚函数

84、内联函数、构造函数、静态成员函数可以是虚函数么

85、析构函数可以调用虚函数,构造函数为什么不可以调用虚函数

86、析构函数可以是纯虚的么

87、为什么需要虚继承,虚继承的实现原理

88、迭代器和普通自指针有什么区别

89、C++4种类型转换

90、如何定义一个只能在堆上创建的类,如何定义一个只能在栈上创建的类

91、标准库函数和系统调用的区别

92、如何区分一段代码是C++还是C代码编写的

93、什么是回调函数,回调函数的使用场景

94、临时对象在什么时候会产生

## 95、说一下C++的返回值优化(先看右值引用)

返回值优化(Return value optimization, RVO)是C++的一项编译优化技术

删除保持函数返回值的临时对象, 可能会省略多次复制构造函数


[C++ 返回值优化](https://blog.csdn.net/fengfengdiandia/article/details/90382547)

[C++之返回值优化](https://www.jianshu.com/p/f3b8c3e4f2ad)

96、protected,public,private在继承中的可见性

97、C++中为什么用模板类

98、子类不能继承父类的函数有哪些

99、虚函数的内存结构,菱形继承的虚函数内存结构

100、谈谈stl标准库的线程安全性

101、成员函数里memset(this,0,sizeof(*this))会发生什么

102、share_ptr的线程安全性

103、vector资源释放

## 二、线程进程面试题总结

1、程序什么时候应该使用线程,什么时候单线程效率高

2、惊群现象

3、C++函数内的静态变量初始化以及线程安全问题

4、C++线程安全的单例类

5、多线程环境带有状态的对象的讨论

6、C++多线程加volatile的错误认识

7、并行编程中多进程和多线程,什么情况下多进程能解决的多线程无法解决

8、如何证明一个数据结构是线程安全的

9、lock-free的实现方式

10、锁的实现方式

11、多线程编程的时候,使用无锁结构会不会比有锁结构更加快

12、linux线程是如何进行切换的

13、Linux 开发,使用多线程还是用 IO 复用 select/epoll

14、异步,多线程和并行的区别

15、Linux 下多线程和多进程程序的优缺点,各自适合什么样的业务场景

16、开发多线程的程序应该注意哪些问题

17、如何测试线程池的性能

18、死锁的原因和避免

19、如何理解互斥锁,条件锁,读写锁以及自旋锁

20、互斥锁,同步锁,临界区,互斥量,信号量,自旋锁之间联系是什么

21、pthread_cond_wait 为什么需要传递 mutex 参数

22、多线程网络编程中如何合理地选择线程数

23、malloc和free是线程安全的吗,在多线程开发时用这两个函数应该注意什么

24、僵尸进程和孤儿进程有什么区别、如何处理

25、Linux系统中 进程 、线程 、时间片的关系

26、在Linux系统中,对于用户创建的进程(线程)来说,CPU分配时间片的单位是线程还是进程

27、内核级调度和用户级调度

28、Linux中进程具有父子层次结构,Windows中没有进程层次,这两种设计各有什么优劣

29、linux用户级进程跟内核线程(进程)有什么差别

30、为什么要区分用户态和内核态

31、从用户空间到内核空间有以下触发手段

32、进程的内存空间布局

33、进程间通信(IPC)方式

34、进程空间和内核空间对内存的管理不同

35、虚拟内存的作用

36、虚拟内存的实现

37、Linux的slab层

38、fork与vfork区别

39、exit()与_exit()区别

40、Linux是如何避免内存碎片的

41、共享内存的实现原理

42、银行家算法

43、linux中断响应机制

44、如何实现守护进程 

45、32位系统一个进程最多有多少堆内存

46、线程安全和不安全的讨论

47、可重入函数与线程安全的区别与联系

48、双重检查锁定模式(DCLP)的风险

49、内存屏障详解

50、原子操作原理

51、Linux有内核级线程么

52、使用线程是如何防止出现大的波峰

53、操作系统中进程调度策略有哪几种

54、线程与进程的区别和联系 线程是否具有相同的堆栈 dll是否有独立的堆栈

55、读者-写者问题

56、哲学家进餐问题

57、进程状态的切换图

三、TCP/IP网络编程面试题总结

1、网络体系结构

2、TCP和UDP有什么区别

3、编写socket套接字的步骤

4、TCP三次握手和四次挥手,以及各个状态的作用

5、Http协议和TCP的区别

6、同步IO和异步IO的区别

7、什么是IOCP

8、什么是网络套接字(Socket)?流套接字(SOCK_STREAM)基于什么协议

9、IP首部、TCP首部、UDP首部、以太网首部

10、TCP和UDP的应用场景

11、如何实现可靠的UDP

12、详细说明TCP状态迁移过程

13、2MSL是什么状态？作用是什么

14、三次握手为什么不是两次或者四次

15、TCP重发机制

16、说说Nagle算法

17、TCP拥塞控制

18、TCP的滑动窗口

19、域名解析的过程

20、ARP的机制

21、RARP的实现

22、http/https 1.0 1.1 2.0的特点和区别

23、Get/post的区别

24、Http返回状态码

25、Http协议相关头

26、浏览器中输入一个URL发生什么,用到那些协议

27、五种IO模型

28、select,poll,epoll的区别

29、UDP中一个包的大小最大能多大

30、Time_wait,close_wait状态产生的原因,keeplive

31、列举你所知道的TCP选项

32、Connect会阻塞检测及防止,socket什么情况下可读  

33、如果select返回可读,结果只读到0字节,什么情况

34、socket什么情况下可读

35、Keepalive是什么东西,如何使用

36、UDP使用connect的好处

37、各层对应的网络设备(路由器、交换机、网关、网桥、集线器等),各层对应的协议

38、数据链路层的CSMA/CD协议

39、IP地址的分类,子网划分

40、TCP精髓问题: 停止等待协议、连续ARQ协议 

41、HTTP缓存机制(cache-control、Expires之类的一系列请求与相应的报头字段

42、session和cookied 区别,禁用cookie后怎么办

43、常用协议的端口

44、三层交换机和路由器的区别

45、什么是TCP的自连接,如何解决

46、单播、多播(组播)和广播的区别

47、当应用程序调用Send之后怎么判断对方是否成功接收

48、静态路由和动态路由各自的优缺点

49、路由器和交换机的不同之处有哪些

50、为什么有时ping服务器第一包丢失

51、tcp 阻塞socket send recv需要注意的操作

52、TCP封包和拆包

53、怎样理解阻塞非阻塞与同步异步的区别

54、epoll: EPOLLLT和EPOLLET的区别

55、epoll事件驱动框架使用注意事项

56、Linux-socket的close和shutdown区别及应用场景

57、TCP带外数据

58、网桥的作用

59、防火墙的端口防护

60、有哪些私有保留地址

61、Ping命令使用的那种报文

62、两台笔记本电脑连起来后ping不通,你觉得有哪些问题造成的

63、Vlan的特点

64、ICMP是属于什么协议,处于那一层

65、IP组播有什么好处

66、DNS欺骗的方式

67、reactor和proactor的区别

68、两台机器A-B进行TCP通讯,进程崩溃会怎么样进程死锁会怎么样进程或机器过载,反应变慢会怎么样进程死循环,拼命发消息会怎么样机器重启会怎么样机器死机会怎么样机器网卡抽风,丢包严重会怎么样交换机或路由器坏了或过载会怎么样路由器过热重启会怎么样A和B之间的带宽被别的服务占用了会怎么样如何诊断以上这些情况. 如果A和B之间有防火墙,还会出哪些情况. 

69、Linux 中每个 TCP 连接最少占用多少内存

70、TCP 能否发送0字节的数据包

71、tcp 协议中为什么syn会消耗一个序号

72、tcp/ip数据包在互联网传输过程中,有哪些头会保持不变

73、linux/unix socket编程并发时什么时候用进程(fork),什么时候用线程(池)

74、如何测量网络发送速度

75、如果将同一个listening socket加入多个epoll, 是不是一种合理的设计？

76、Tcp客户端的正确关闭方式

77、对一个已经关闭了的socket 的Server 调用write操作

78、怎样实时判断socket链接状态

79、socket套接字在多线程发送数据时要加锁吗

80、TCP中已有SO_KEEPALIVE选项,为什么还要在应用层加入心跳包机制

81、TCP 协议下 socket 有可能丢包吗

82、如何理解 TCP/IP, SPDY, WebSocket 三者之间的关系

83、为什么每台电脑都要设置子网掩码

84、为什么以太网无法接收大于1500字节的数据包

85、OSI七层模型中,每一层的数据包都是谁生成和解包的

86、为什么网关与主机可以不在同一个网段

87、NAT和DHCP 的区别是什么

88、OSI模型中,一个协议应该属于哪一层是以什么为标准划分的

101、TCP三次握手的过程,seq的变化是一直都是加1吗

102、使用Linuxepoll模型,水平触发模式;当socket可写时,会不停的触发socket可写的事件,如何处理

四、Linux操作面试题

1、与CPU、内存、磁盘相关的命令(top free df fdisk)

2、与网络相关的命令netstat , tcpdump等

3、sek,awk,grep三个强大的命名,分别用与格式化修改,统计,和正则查找

4、ipcs和ipcrm命令

5、查找当前目录以及字母下以.c结尾的文件,且文件中包含”hello world”的文件的路径

6、创建定时任务

7、gdb用法

8、linux的内存管理机制

9、/proc存在哪里

10、Linux状态分析: CPU(top)、内存(top和free,注意buffer和cache区别)、磁盘(fdisk和df)、IO(iostat)等

11、shell脚本

12、Linux目录结构

13、linux中断响应机制

14、linux文件系统结构和启动流程

15、防火墙iptables

16、轮询任务调度和抢占式任务调度的区别

17、查看进程ps ps aux

18、删除进程kill -9

19、查看进程树pstree

20、查看占用端口的进程netstat netstat -anp | grep port

21、正则表达式grep printf awk

22、管线指令 ls -al /etc | less

23、sort 进行排序

24、双向输出重定向

25、打包压缩

26、目录的 inode 与 block

27、实体链接与符号链接

28、文件系统的组成

29、文件与目录的基本操作

30、文件属性以及权限的修改

31、分区

32、内核模块的位置在哪里

33、SMTP, DNS, FTP, DHCP, SSH 和 squid 使用的默认端口号是哪些

34、Linux中不同的网络绑定模式有哪些

35、如何检查默认路由以及路由表

36、在Linux 中什么是平均负载

37、请描述Linux系统优化的12个步骤

38、描述Linux下软链接和硬链接的区别

39、描述Linux下文件删除的原理

40、给出正确的关机和重启服务器的命令

41、请简述修改/etc/sudoers配置文件的注意事项

42、如果一台办公室内主机无法上网(打不开网站),请给出你的排查步骤

43、请简述Linux启动过程中几个重要配置文件的执行过程

44、请输出你知道的20 个LINUX 命令及作用

45、企业中Linux服务器系统分区标准是什么

46、某一天突然发现Linux系统文件只读,该怎么办呢？完整操作步骤

47、某一天误操作,执行了rm-rf* ,会有哪些情况发生？请举例

48、一般可以使用什么软件远程linux服务器？通过什么上传文件和下载文件

49、Linux内核引导时,从哪个文件中读取要加载的文件系统

50、Linux文件系统中每个文件用 i节点 来标识

51、简述网络文件系统NFS,并说明其作用

52、简述DNS进行域名解析的过程

53、简述Linux文件系统通过i节点把文件的逻辑结构和物理结构转换的工作过程

54、nfs 协议用于实现Unix(/linux)主机之间的文件系统共享

55、欲发送10个分组报文测试与主机abc.tuu.edu.cn的连通性,应使用的命令和参数

56、进程的运行有两种方式,即独立运行和使用父进程运行

57、vi编辑器具有两种工作模式命令模式和输入模式

58、vi的使用

59、内核分为进程管理系统内存管理系统I/O管理系统和文件管理系统等四个子系统

60、安装Linux系统对硬盘分区时,必须有两种分区类型: 文件系统分区和交换分区

五、数据结构与算法

1、单链表的逆置

2、常见排序算法和稳定性,效率分析

3、静态链接和动态链表的区别

4、海量数据处理的知识点

5、AVL树和R-B树的查找,插入,删除的效率,区别  //数据结构的内容

6、判断一个链表是否存在循环

7、寻找最大的K个数

8、统计数组中出现最多的数

9、字符串匹配

10、二分查找

11、实现Strcpy

12、实现快速排序

13、建堆,建堆的时间复杂度

14、HASH策略常见的有哪些

15、HASH表实现

16、二叉树结构,二叉查找树的实现

17、二叉树的六种遍历

18、二叉树的按层遍历

19、编写简单的String类

20、编写strcpy、strcat、strcmp、memcpy、memmove

21、求二叉树的深度

22、判断一棵二叉树是否是平衡二叉树

23、求二叉树第K层节点个数

24、求二叉树中两个节点的最大距离

25、判断一棵二叉树是否为完全二叉树

26、重建二叉树,依据前序遍历结果和中序遍历结果

27、实现简单的智能指针

28、实现stl::string的写时copy

29、什么是大小端模式,编写代码区分大小端

30、链表的插入删除、单向链表、双向链表

31、反向打印链表

32、打印倒数第K个节点

33、链表是否有环

34、冒泡、选择、插入、快速、归并、堆排序、希尔、桶

35、背包问题

36、深度优先、广度优先、单源最小路径、任意两点最小路径

37、最大堆、最小堆、堆如何调整

38、两个有序数组求中位数

39、最长上升子序列

40、海量数据排序

41、链表翻转

42、最长公共子序列

43、海量数据topk问题

44、蓄水池抽样算法

45、排序算法性能比较,时间复杂度、稳定性、比较

46、1-100之间所有素数之和

47、队列的实现

48、字符串匹配

49、数组存储超大数

50、回文字符串

51、判断两个数组是否有相同的数字

52、大数据中找中位数

53、B树、B+树、红黑树、AVL树

54、单链表排序

55、查找链表中间节点

56、删除无头非尾节点

57、约瑟夫环

58、如何从100万个数中找出最大的前100个数

59、找出数组中重复的数字

60、计算斐波那契数列

61、滑动窗口的最大值

62、0~n-1 中缺失的数字

63、连续子数组的最大和

64、删除链表中重复的节点

65、矩阵中的路径

66、调整数组顺序使奇数位于偶数前面

67、最长不重复子串

68、天平不平衡找假币问题

69、栈的逆序

70、数组的逆序对

71、二叉搜索树的第K个节点

72、树上最远距离

73、折纸问题

74、根据前序和中序遍历求后序

75、完全二叉树判断、平衡二叉树判断、二叉查找树判断

76、荷兰国旗问题

77、字符串-全排列问题

78、无环链表判断相交

79、用两个栈实现队列

80、最大连续数列和

81、矩阵取值问题

82、最大和子矩阵

83、最长公共子序列和最长递增子序列

84、最小编辑代价

85、动态规划和递归-魔术索引

86、确定字符串互异

87、基本字符压缩

88、空格替换

89、确定两个字符串乱序同构

90、A+B问题

91、尾部的零

92、第K大元素

93、有一座高度是10级台阶的楼梯,从下往上走,每跨一步只能向上1级或者2级台阶. 要求用程序,来求出一共有多少种走法. 

94、一个有getMin功能的栈

95、从上往下打印二叉树的每个节点,同层节点从左到右

96、最长单词(Lintcode)

97、单例(Lintcode)

98、Fizz Buzz问题(LintCode)

99、二分查找

100、N皇后问题
---
title: "C_C++-动态库"
date: 2023-02-28
categories: [C_C++]
tags: [C_C++]
excerpt: "动态库"
---

# 动态库

动态库(Dynamic Library), 又称动态链接库(Dynamic Link Library, DLL), 是一种在程序运行时加载的库文件

它与静态库主要区别在于动态库代码并不在程序编译时直接包含, 而是在程序执行时根据需要动态加载

## 特点

- 运行时加载

动态库代码在程序运行时被加载到内存, 而不是在编译时就包含在可执行文件中, 使得程序可在需要时才使用特定库功能, 从而节省内存。

- 共享性

多个程序可以共享同一个动态库实例, 意味若多应用程序使用相同库, 则可共享内存中相同代码, 减少资源占用

- 版本控制

动态库可以单独更新, 不需要重新编译依赖于它的应用程序, 若功能更改, 用户只需替换库文件, 而不必重新编译所有相关程序

- 支持多语言

动态库通常可以被多种编程语言调用, 使得在不同开发环境中非常灵活

```mermaid
graph LR;
    X(格式)
    X --> A(Linux) --> A1(.so)
    X --> B(Windows) --> B1(.dll)
    X --> C(macOS) --> C1(.dylib)
```

## 开发

下面是一个动态库示例示例代码, 设生成目标动态库libHelloAPI.dll/so

HelloAPI.hpp

```cpp
#include <iostream>

#ifndef __INCLUDE_DLL_HPP__
#define __INCLUDE_DLL_HPP__

#if defined(_WIN32)
    #define DLL_EXPORT __declspec(dllexport)
    #define DLL_IMPORT __declspec(dllimport)
#elif defined(__linux__)
    #define DLL_EXPORT __attribute__((visibility("default")))
    #define DLL_IMPORT
#endif

#ifdef __cplusplus
extern "C" {
#endif

DLL_EXPORT void Hello();

#ifdef __cplusplus
}
#endif

#endif
```

HelloAPI.cpp

```c++
#include "HelloAPI.hpp"

void Hello() {
    std::cout << "Hello World" << std::enl;
}
```

在创建动态库时, C和C++有一些关键差异特点

### 特点

#### 名称修饰(Name Mangling)

C++支持函数重载, 导致C++编译器会对函数名称进行称为名称修饰的特殊编码,以区分不同函数签名

C语言不支持函数重载, 因此C编译器不会对函数名进行修饰

若在C++中需要导出C风格接口(即无名称修饰), 需用 `extern "C"` 告知编译器按C语言规则导出

```c++
#ifdef __cplusplus
extern "C" {
#endif

// 具体函数.....

#ifdef __cplusplus
}
#endif
```

#### 导出符号(Symbol Export)

为将函数从动态库中导出被其他程序使用, 需在函数前添加导出语句出函数符号

```c++
#ifdef _WIN32
    #define DLL_EXPORT __declspec(dllexport)
    #define DLL_IMPORT __declspec(dllimport)
#elif defined(__linux__)
    #define DLL_EXPORT __attribute__((visibility("default")))
    #define DLL_IMPORT
#endif

// 此时库中Hello函数才能被其他程序调用
DLL_EXPORT void Hello();
```

### 编译

#### 命令行

```mermaid
graph LR;
    X(参数)
    X --> A(fPIC) --> A1(创建与地址无关编译程序 ,使在多个应用程序间共享)
    X --> B(shared) --> B1(尽量使用动态库, 但需要系统动态库)
```

```sh
# Linux
g++ [*.cpp] -fPIC -shared -o [*.so]

# Windows
g++ [*.cpp] -fPIC -shared -o [*.dll]
```

将HelloAPI.hpp与HelloAPI.cpp生成HelloAPI动态库

- Linux

![](/Resource/Imgur/20241105_211605.jpg)

若报找不到库文件错误, 移动动态库到/usr/lib目录

```sh
sudo mv [*.so] /usr/lib
```

- Windows

![](/Resource/Imgur/20241105_214137.jpg)

#### CMake

CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.16)
 
project(HelloAPI)

add_library(${PROJECT_NAME}_Shared SHARED "")

target_include_directories(${LIB_NAME} PRIVATE
    ${CMAKE_SOURCE_DIR}/HelloAPI.hpp
)

target_sources(${LIB_NAME} PRIVATE
    ${CMAKE_SOURCE_DIR}/Source/HelloAPI.cpp
)

set_target_properties(${LIB_NAME} PROPERTIES OUTPUT_NAME ${PROJECT_NAME})
```

- Linux

![](/Resource/Imgur/20241105_212501.jpg)

- Windows

![](/Resource/Imgur/20241105_214251.jpg)

### 分类

#### 源文件不含类

不含类时生成动态库可直接调用

例如上面HelloAPI.hpp与HelloAPI.cpp所生成动态库

#### 源文件含类

若源文件中含类时, 需再封装一层调用

MyClass.hpp

```c++ 
#include <iostream>

class MyClass {
public:
    MyClass() = default;
    ~MyClass() = default;
    void SetValue(const int val);
    void Print() const;
private:
    int mValue;
};
```

MyClass.cpp

```c++ 
#include "MyClass.hpp"

void MyClass::SetValue(const int val) {
    this->mValue = val;
}
void MyClass::Print() const {
    std::cout << "mValue = " << mValue << std::endl;
}
```

MyClassDLL.hpp

```c
#include "MyClass.hpp"

#ifdef _WIN32
    #define DLL_EXPORT __declspec(dllexport)
    #define DLL_IMPORT __declspec(dllimport)
#else
    #define DLL_EXPORT __attribute__((visibility("default")))
    #define DLL_IMPORT
#endif

#ifdef __cplusplus
extern "C" {
#endif

DLL_EXPORT void* MyClassCreate();
DLL_EXPORT void  MyClassDestroy(void* handle);
DLL_EXPORT void  MyClassSetValue(void* handle, int val);
DLL_EXPORT void  MyClassPrint(void* handle);

#ifdef __cplusplus
}
#endif
```

MyClassDLL.cpp

```c++
#include "MyClassDLL.hpp"

DLL_EXPORT void* MyClassCreate() {
    return new MyClass();
}
DLL_EXPORT void MyClassDestroy(void* handle) {
    delete static_cast<MyClass*>(handle);
}
DLL_EXPORT void MyClassSetValue(void* handle, int val) {
    MyClass* obj = static_cast<MyClass*>(handle);
    obj->SetValue(val);
}
DLL_EXPORT void MyClassPrint(void* handle) {
    MyClass* obj = static_cast<MyClass*>(handle);
    obj->Print();
}
```

#### 模板

- 模板类

TemplateClass.hpp

```c++
#ifndef __INCLUDE_TEMPLATE_CLASS_HPP__
#define __INCLUDE_TEMPLATE_CLASS_HPP__

#include <iostream>

#ifdef _WIN32
    #define DLL_EXPORT __declspec(dllexport)
    #define DLL_IMPORT __declspec(dllimport)
#else
    #define DLL_EXPORT __attribute__((visibility("default")))
    #define DLL_IMPORT
#endif

template<typename T>
class  TemplateClass {
public:
    TemplateClass() = default;
    ~TemplateClass() = default;

    T Add(T a, T b);
};

#endif
```

TemplateClass.cpp

```c++
#include "TemplateClass.hpp"

// 模板实例化
template class DLL_EXPORT TemplateClass<double>;

template<typename T>
T TemplateClass<T>::Add(T a, T b) {
	std::cout << "TemplateClass::Add" << std::endl;
	
    return T(a + b);
}
```

- 模板函数

TemplateFunction.hpp

```c++
#ifndef __INCLUDE_TEMPLATE_FUNTCION_HPP__
#define __INCLUDE_TEMPLATE_FUNTCION_HPP__

#include <iostream>

#ifdef _WIN32
    #define DLL_EXPORT __declspec(dllexport)
    #define DLL_IMPORT __declspec(dllimport)
#else
    #define DLL_EXPORT __attribute__((visibility("default")))
    #define DLL_IMPORT
#endif

template<typename T>
T Add(T a, T b);

#endif
```

TemplateFunction.cpp

```c++
#include "TemplateFunction.hpp"

// 模板实例化
template DLL_EXPORT Add<int>(int, int);
template DLL_EXPORT Add<double>(double, double);
template DLL_EXPORT Add<std::string>(std::string, std::string);

template<typename T>
T Add(T a, T b) {
    std::cout << "TemplateFunction::Add" << std::endl;
    return T(a + b);
}
```

## 调用

### 代码调用

#### 头文件

若有生成动态库.h/.hpp文件, 可直接引用头文件调用, 例如调用上面HelloAPI动态库

```c++
// Main.cpp
#include "HelloAPI.hpp"

int main(void) {
    Hello();
    return 0;
}
```

- 命令行

![](/Resource/Imgur/20241105_223904.jpg)

若报找不到库文件错误, 则移动库文件到/usr/lib目录即可

- CMake

CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.16)
 
project(Main)

add_library(HelloAPI SHARED "")

target_sources(HelloAPI PUBLIC
    ${CMAKE_SOURCE_DIR}/HelloAPI.cpp
)

add_executable(${PROJECT_NAME} "")

target_sources(${PROJECT_NAME} PRIVATE
    ${CMAKE_SOURCE_DIR}/Main.cpp
)

target_link_libraries(${PROJECT_NAME}
    HelloAPI
)
```

![](/Resource/Imgur/20241105_224752.jpg)

#### 函数读取

设读取动态库仍为HelloAPI, 而当前无头文件, 且知悉待调用库中函数名称, 则可通过系统函数进行库调用

```c++
// Main.cpp
#include<iostream>

#if defined (_WIN32) | defined (_WIN64)
    #include<windows.h>
#elif defined (__linux__)
    #include <dlfcn.h>
#endif

typedef void(*VoidFunc)();

int main() {
    // 加载
#if defined (_WIN32) | defined (_WIN64)
	HMODULE handle = LoadLibrary("HelloAPI.dll");
    if (!handle) {
        std::cerr << "无法加载动态库: " << GetLastError() << std::endl;
    }

    VoidFunc helloFunc = (VoidFunc)GetProcAddress(handle, "Hello");
    if (helloFunc == nullptr) {
        std::cerr << "无法找到函数: " << GetLastError() << std::endl;
		FreeLibrary(handle);
    }

#elif defined (__linux__)
	void* handle = dlopen("HelloAPI.so", RTLD_LAZY | RTLD_LOCAL);
    if (!handle) {
        std::cerr << "无法加载动态库: " << dlerror() << std::endl;
    }

    VoidFunc helloFunc = (VoidFunc)dlsym(handle, "Hello");
    if (helloFunc == nullptr) {
        std::cerr << "无法找到函数: " << dlerror() << std::endl;
        dlclose(handle);
    }
#endif

    // 调用
    helloFunc();

    // 卸载
#if defined (_WIN32) | defined (_WIN64)
    FreeLibrary(handle);
#elif defined (__linux__)
    dlclose(handle);
#endif
    return 0;
}
```

Linux编译时需链接动态链接库的加载器库`dl`, Windows则不需要

- 命令行

```sh
g++ Main.cpp -o Main (-ldl)
```

![](/Resource/Imgur/20241105_225639.jpg)

![](/Resource/Imgur/20241105_231632.jpg)

- CMake

CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.16)
 
project(Main)

add_executable(${PROJECT_NAME} "")

target_sources(${PROJECT_NAME} PRIVATE ${CMAKE_SOURCE_DIR}/Main.cpp)

if(CMAKE_HOST_SYSTEM_NAME MATCHES "Linux")
    target_link_libraries(${PROJECT_NAME} dl)
endif()
```

![](/Resource/Imgur/20241105_230630.jpg)

![](/Resource/Imgur/20241105_232529.jpg)

## 开发

### VS2022

创建解决方案Project与动态链接库项目DllTest, 在Project项目中调用DllTest中生成的动态库

![](/Resource/Imgur/20241104_212033.jpg)

#### 编写

DllTest/pch.h 

```c++
#include <iostream>

#define DLLEXPORT __declspec(dllexport)

#ifdef __cplusplus
extern "C" {
#endif

DLLEXPORT void PrintInfo();

DLLEXPORT int Add(int x, int y);

#ifdef __cplusplus
}
#endif
```

DllTest/pch.cpp

```c++
void PrintInfo() {
    std::cout << "Hello World" << std::endl;
}

int Add(int x, int y) {
    return x + y;
}
```

![](/Resource/Imgur/20241104_210847.jpg)

此时生成动态库DllTest.dll与动态库的导入库DllTest.lib

![](/Resource/Imgur/20241104_211453.jpg)

#### 使用

将pch.h 与生成的DllTest.dll、DllTest.liub拷贝到Project项目中

![](/Resource/Imgur/20241104_212139.jpg)

新建Main.cpp

```c++
#include "pch.h"

int main() {
    PrintInfo();
    std::cout << Add(1, 2) << std::endl;
}
```
![](/Resource/Imgur/20241026_143654.jpg)

添加DllTest.lib路径, 用于导入动态库

![](/Resource/Imgur/20241104_212253.jpg)

![](/Resource/Imgur/20241104_212434.jpg)

![](/Resource/Imgur/20241104_212524.jpg)

运行结果

![](/Resource/Imgur/20241104_212607.jpg)

### Python读取

```py
from ctypes import *

cdll = CDLL("./HelloAPI.so")

print(cdll.Hello())


```
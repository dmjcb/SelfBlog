---
title: "C_C++-CMake使用"
date: 2024-10-22
categories: [C_C++, CMake]
tags: [C_C++]
excerpt: "CMake使用"
---

> - [cmake使用详细教程（日常使用这一篇就足够了）](https://blog.csdn.net/iuu77/article/details/129229361)
> - [CMake学习笔记05--ExternalProject_Add模块](https://blog.csdn.net/zym326975/article/details/106118063)

# CMake使用

## 单CMakeLists.txt

### 单文件

```sh
.
├── CMakeLists.txt
└── Main.cpp
```

Main.cpp

```c
#include <iostream>
 
int main() {
    std::cout << "Hello World" << std::endl;
    return 0;
}
```

CMakeLists.txt

```cmake 
cmake_minimum_required(VERSION 3.30)
 
project(Main)
 
add_executable(Main Main.cpp)
```

![](/Resource/Imgur/20241022204809.png)

![](/Resource/Imgur/20241022205030.png)

### 多目录

```sh
.
├── Bin
├── CMakeLists.txt
├── Include_1
│   └── TestFunc_1.hpp
├── Include_2
│   └── TestFunc_2.hpp
├── Main.cpp
├── Source_1
│   └── TestFunc_1.cpp
└── Source_2
    └── TestFunc_2.cpp
```

Include_1/TestFunc_1.hpp

```c++
#include <iostream>
void Hello_1();
```

Include_2/TestFunc_2.hpp

```c
#include <iostream>
void Hello_2();
```

Source_1/TestFunc_1.cpp

```c
#include "TestFunc_1.hpp"
void Hello_1() {
    std::cout << "Hello_1" << std::endl;
}
```

Source_2/TestFunc_2.cpp

```c
#include "TestFunc_2.hpp"
void Hello_12() {
    std::cout << "Hello_2" << std::endl;
}
```

Main.cpp

```c
#include "TestFunc_1.hpp"
#include "TestFunc_2.hpp"

int main() {
    Hello_1();
    Hello_2();
    return 0;
}
```

CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.16)
 
project(Main)

add_executable(${PROJECT_NAME} "")

target_include_directories(${PROJECT_NAME} PRIVATE
    ${CMAKE_SOURCE_DIR}/Include_1
    ${CMAKE_SOURCE_DIR}/Include_2
)

target_sources(${PROJECT_NAME} PRIVATE
    ${CMAKE_SOURCE_DIR}/Source_1/TestFunc_1.cpp
    ${CMAKE_SOURCE_DIR}/Source_2/TestFunc_2.cpp
    ${CMAKE_SOURCE_DIR}/Main.cpp
)
```

![](/Resource/Imgur/20241024224619.png)

### 生成库

```sh
.
├── CMakeLists.txt
├── Include
│   └── API.hpp
├── Main.cpp
└── Source
    └── API.cpp
```

Include/API.hpp

```c++
#ifndef __INCLUDE_API_HPP__
#define __INCLUDE_API_HPP__

#include <iostream>

#ifdef _WIN32
    #define API_EXPORT __declspec(dllexport)
    #define API_IMPORT __declspec(dllimport)
#else
    #define API_EXPORT __attribute__((visibility("default")))
    #define API_IMPORT
#endif

#ifdef __cplusplus
extern "C" {
#endif

void Display();

int Add(int x, int y);

#ifdef __cplusplus
}
#endif

#endif
```

Source/API.cpp

```c
#include "API.hpp"
void Display() {
    std::cout << "Print API success!" << std::endl;
}

int Add(int x, int y) {
    return x + y;
}
```

CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.16)
 
project(API)

# 设置库生成目录
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/Library)

add_library(${PROJECT_NAME}_Shared SHARED "")
add_library(${PROJECT_NAME}_Static STATIC "")

foreach(LIB_NAME ${PROJECT_NAME}_Shared ${PROJECT_NAME}_Static)
    target_include_directories(${LIB_NAME} PRIVATE
        ${CMAKE_SOURCE_DIR}/Include
    )

    target_sources(${LIB_NAME} PRIVATE
        ${CMAKE_SOURCE_DIR}/Source/API.cpp
    )

    set_target_properties(${LIB_NAME} PROPERTIES OUTPUT_NAME ${PROJECT_NAME})
endforeach()
```

![](/Resource/Imgur/20241024221856.png)

Library目录下生成动静态库

```sh
.
├── CMakeLists.txt
├── Include
│   └── API.hpp
├── Main.cpp
├── Library
│   ├── libAPI.a
│   └── libAPI.so
└── Source
    └── API.cpp
```

### 链接库

```sh
.
├── CMakeLists.txt
├── Include
│   └── API.hpp
├── Main.cpp
├── Library
│   ├── libAPI.a
│   └── libAPI.so
└── Source
    └── API.cpp
```

Main.cpp

```c
#include "API.hpp"

int main(void) {
    int res = Add(1, 2);
    std::cout << "res = " << res << std::endl;

    Display();

    return 0;
}
```

CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.16)
 
project(Main)

# 设置可执行文件生成目录
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/Bin)

# 将从Library目录中寻找的API库路径与名称值存储于FUNC_LIB
find_library(FUNC_LIB API ${PROJECT_SOURCE_DIR}/Library)

add_executable(${PROJECT_NAME} "")

target_include_directories(${PROJECT_NAME} PRIVATE
    ${CMAKE_SOURCE_DIR}/Include
)

target_sources(${PROJECT_NAME} PRIVATE
    ${CMAKE_SOURCE_DIR}/Main.cpp
)

target_link_libraries(${PROJECT_NAME} PRIVATE 
    ${FUNC_LIB}
)
```

![](/Resource/Imgur/20241024222701.png)

## 多CMakeLists.txt

### 生成库链接

在Hello目录中生成libAPI库并链接

```sh
.
├── CMakeLists.txt
├── Hello
│   ├── CMakeLists.txt
│   ├── Include
│   │   └── API.hpp
│   └── Source
│        └── API.cpp
└── Main.cpp
```



Hello/CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.16)
 
project(Hello)

set(LIBRARY_OUTPUT_PATH ${CMAKE_SOURCE_DIR}/Library)

# 添加动态库libAPI.so
add_library(${PROJECT_NAME} SHARED "")

# 添加目标文件引用的头文件
target_include_directories(${PROJECT_NAME} PRIVATE
    ${PROJECT_SOURCE_DIR}/Include
)

# 添加目标文件引用的源文件
target_sources(${PROJECT_NAME} PRIVATE
    ${PROJECT_SOURCE_DIR}/Source/API.cpp
)
```

根目录CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.16)
 
project(Main)

# 设置可执行文件输出路径
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/Bin)

# 设置预链接库名称
set(EXTRA_LIBS ${EXTRA_LIBS} API)

# 添加子目录执行
add_subdirectory(API)

# 生成可执行文件
add_executable(${PROJECT_NAME} "")

# 添加目标文件引用的头文件
target_include_directories(${PROJECT_NAME} PRIVATE
    ${CMAKE_SOURCE_DIR}/API/Include
)

# 添加目标文件引用的源文件
target_sources(${PROJECT_NAME} PRIVATE
    ${CMAKE_SOURCE_DIR}/Main.cpp
)

# 添加目标文件链接库
target_link_libraries(${PROJECT_NAME} ${EXTRA_LIBS})
```

![](/Resource/Imgur/20241022231348.png)

## 三方库

### 源码编译

若第三方库没有CMake配置文件, 且能访问源码, 则可将库源代码直接添加到项目中, 并使用add_subdirectory编译

```cmake
add_subdirectory(SomeLibrary)

target_link_libraries(MyExecutable PRIVATE SomeLibrary)
```

### FetchContent

CMake 3.11及以上版本引入FetchContent模块, 可直接下载第三方库编译

#### 编译fmt库

- 主CMakeLists.txt调用

```sh
.
├── CMakeLists.txt
├── Main.cpp
└── Extern
```

CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.17)
project(Main)

set(CMAKE_CXX_STANDARD 14)

add_executable(${PROJECT_NAME} "")

# 引入FetchContent
include(FetchContent)

FetchContent_Declare(fmt
    # git仓库地址与版本
    GIT_REPOSITORY https://github.com/fmtlib/fmt.git
    GIT_TAG        9.1.0
    # 库源码位置
    SOURCE_DIR     ${CMAKE_SOURCE_DIR}/Extern/fmt
)

# 构建库
FetchContent_MakeAvailable(fmt)

# 添加三方库头文件目录
target_include_directories(${PROJECT_NAME} PRIVATE 
    ${CMAKE_SOURCE_DIR}/Extern/fmt/include
)

target_sources(${PROJECT_NAME} PUBLIC
    Main.cpp
)

target_link_libraries(${PROJECT_NAME} PRIVATE fmt::fmt)
```

Main.cpp

```c++
#include "fmt/core.h"
#include <string>

int main(){
    std::string world = fmt::format("Hello {0}", "World");
    fmt::print("{}\n", world);
}
```

![](/Resource/Imgur/20241030_003207.jpg)

![](/Resource/Imgur/20241030_003358.jpg)

此时可发现第三方库已经下载

![](/Resource/Imgur/20241030_205530.jpg)

- .cmake模块调用

建立CMake/FMT.cmake, 用于完成fmt库的安装

```sh
.
├── CMakeLists.txt
├── Main.cpp
├── CMake
│   └── FMT.cmake
└── Extern
```

FMT.cmake

```cmake
include(FetchContent)

FetchContent_Declare(fmt
    GIT_REPOSITORY https://github.com/fmtlib/fmt.git
    GIT_TAG        9.1.0
    SOURCE_DIR     ${CMAKE_SOURCE_DIR}/Extern/fmt
)

FetchContent_MakeAvailable(fmt)
```

CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.17)
project(Main)

set(CMAKE_CXX_STANDARD 14)
set(CMAKE_MODULE_PATH  ${CMAKE_SOURCE_DIR}/CMake)

# 导入MFT模块
include(FMT)

add_executable(${PROJECT_NAME} "")

target_include_directories(${PROJECT_NAME} PRIVATE
    ${CMAKE_SOURCE_DIR}/Extern/fmt/include
)

target_sources(${PROJECT_NAME} PUBLIC
    Main.cpp
)

target_link_libraries(${PROJECT_NAME} PRIVATE 
    fmt::fmt
)
```


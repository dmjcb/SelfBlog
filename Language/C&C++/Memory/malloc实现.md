<!--
 * @Brief        : 
 * @Author       : dmjcb
 * @Date         : 2023-03-14 22:27:29
 * @LastEditors  : dmjcb@outlook.com
 * @LastEditTime : 2024-09-28 13:47:26
-->

# malloc底层实现

```c
#include<stdio.h>
#include<malloc.h>

int main(void) {
    int *p = (int *)malloc(sizeof(int));

    free(p);
    p = NULL;

    return 0;
}
```

malloc其采用内存池的方式, 以减少内存碎片和系统调用的开销

malloc采用隐式链表结构将堆区分成连续的、大小不一的块, 包含已分配块和未分配块, 以块作为内存管理的基本单位

malloc采用显示链表结构来管理所有的空闲块, 使用一个双向链表将空闲块连接起来, 每一个空闲块记录了一个连续的、未分配的地址

## 申请

- 空闲链表

空闲存储空间以空闲链表的方式组织(地址递增), 每个块包含一个长度、一个指向下一块的指针以及一个指向自身存储空间的指针

申请请求时, malloc会扫描空闲链表, 直到找到一个足够大的块为止(首次适应), 因此每次调用malloc时并不是花费了完全相同的时间

### 查找算法

- 首次适配

第一次找到足够大的内存块就分配, 这种方法会产生很多的内存碎片

- 下一次适配

等第二次找到足够大的内存块就分配, 这样会产生比较少的内存碎片

- 最佳适配

对堆进行彻底的搜索, 从头开始遍历所有块, 使用块大小大于目标大小且差值最小的块作为此次分配的块

### 查找内存块存在

- 若与请求的大小相符

将其从链表中移走并返回

- 若该块太大

将内存块分为两部分, 尾部的部分返回用户, 剩下部分留在空闲链表中(更改头部信息), 因此malloc分配的是一块连续的内存

### 查找内存块不存在

- 若申请空间小于128k

调用brk(), 通过移动堆区末尾地址指针_enddata, 申请空间

- 若申请空间大于128k

mmap() 系统调用函数来在虚拟地址空间中(堆和栈中间, 称为"文件映射区域")找一块空间来开辟

#### mmap功能

- 映射磁盘文件到内存中

- 匿名映射, 不映射磁盘文件, 而向映射区申请一块内存

## 释放

释放时, 首先搜索空闲链表, 找到可以插入被释放块的合适位置

如果与被释放块相邻的任一边是一个空闲块, 则将这两个块合为一个更大的块, 以减少内存碎片. 

## 管理

brk、sbrk、mmap都属于系统调用, 若每次申请内存, 都调用这三个, 那么每次都会产生系统调用, 影响性能

其次, 这样申请内存容易产生碎片, 因为堆是从低地址到高地址, 如果高地址的内存没有被释放, 低地址的内存就不能被回收

所以malloc采用的是内存池的管理方式(ptmalloc)

Ptmalloc 采用边界标记法将内存划分成很多块, 从而对内存的分配与回收进行管理. 

为了内存分配函数malloc的高效性, ptmalloc会预先向操作系统申请一块内存供用户使用, 当我们申请和释放内存的时候, ptmalloc会将这些内存管理起来, 并通过一些策略来判断是否将其回收给操作系统. 

这样的最大好处是使用户申请和释放内存的时候更加高效, 避免产生过多的内存碎片

---
title: "C-概念-内存分配"
date: 2021-02-11
categories: [C&C++]
tags: [C&C++]
excerpt: "内存分配"
---

# 内存分配

## 分配方式

### 静态存储区域分配

由编译器自动分配和释放, 在程序编译时已分配好

在程序整个运行期间都存在, 直到整个程序运行结束时才被释放, 如全局变量与static变量

### 栈分配

内存中栈区主要用于分配局部变量空间, 由编译器自动分配和释放, 处于相对较高地址, 栈地址向`低地址`方向增长

在执行函数时函数内局部变量存储单元都可以在栈上创建, 函数执行结束时这些存储单元将被自动释放

栈内存分配运算内置于处理器指令集中, 其运行效率一般很高, 但是分配内存容量有限

### 堆分配

内存中堆区则主要用于分配程序员申请的内存空间, 堆地址向`高地址`方向增长

运行时使用内存分配函数来申请任意内存, 使用完后再使用内存释放函数来释放内存

动态内存整个生存期由程序员决定, 若在堆上分配了内存空间, 必须及时释放, 否则将会出现内存泄漏等错误

#### malloc

```c
void *malloc(size_t size);
```

malloc 用于从堆中分配内存

| 参数   | 说明                                                                           |
| ------ | ----------------------------------------------------------------------------- |
| size_t | 申请空间字节数<br>成功会返回该内存空间地址(不会自动进行初始化)<br>失败返回 NULL |
| void * | 该函数返回类型不确定, 通过接收指针变量从而进行类型转换                           |

分配内存时需注意, 即使在程序关闭时系统会自动回收该手动申请内存, 也要进行手动释放, 以保证内存能够在不需要时返回至堆空间, 使内存能够合理分配使用

#### free

```c
void free(void *ptr);
```

free用于从堆中释放内存, 释放需将指针指向NULL, 否则会出现野指针

```c
#include<stdio.h>
#include<malloc.h>

int main(void){
    char *p1 = (char *)malloc(sizeof(char));
    char *p2 = (char *)malloc(sizeof(char));

    printf("p1 = %p\n", p1);
    printf("p2 = %p\n", p2);

    free(p1);
    p1 = NULL;

    free(p2);
    p2 = NULL;
}
```

![](/assets/SelfImgur/20241021190853.png)

动态分配内存位于堆区中, 堆地址向`高地址方向`增长

```c
#include <stdio.h>
#include <malloc.h>

int main(void) {
    const int SIZE = 4;
    int *p = (int *)malloc(SIZE * sizeof(int));

    for(int i = 0; i < SIZE; i++) {
        printf("&p[%d]=%p\n", i, &p[i]);
    }

    free(p);
    p = NULL;
}
```

![](/assets/SelfImgur/20241021191114.png)

## 对比

### 碎片

频繁分配和释放不同大小堆空间会造成内存空间不连续, 产生大量碎片, 导致程序效率降低

栈不存在这个问题

### 效率

- 栈

栈是机器系统提供的数据结构, 计算机在底层对栈提供支持

如分配专门寄存器存放栈地址, 压栈出栈都有专门执行指令, 所以栈效率较高

一般而言, 只要栈剩余空间大于所申请空间, 系统就将为程序提供内存, 否则将报异常提示栈溢出

- 堆

堆是由 C/C++ 函数库提供, 为分配一块堆内存, 操作系统有一个记录空闲内存地址的链表

当系统收到程序申请时会遍历该链表, 寻找第一个空间大于所申请空间的堆节点, 然后将该节点从空闲节点链表中删除, 并将该节点空间分配给程序

对于大多数系统, 会在这块内存空间首地址处记录本次分配大小, 这样 delete 语句才能正确释放本内存空间

另外, 由于找到堆节点大小不一定正好等于申请大小, 系统会自动将多余部分重新放入空闲链表中, 堆分配效率比栈要低得多

### 申请大小限制

栈是一块连续内存区域

地址增长方向向下(内存地址减小方向)进行, 栈顶地址和栈最大容量一般由系统预先规定好, 若申请空间超过栈剩余空间时, 会提示溢出错误

相对于堆, 能够从栈中获得空间相对较小

操作系统用链表来存储空闲内存地址(内存区域不连续), 链表遍历方向由低地址向高地址进行

因此, 堆内存申请大小受限于计算机系统中有效虚拟内存

### 存储内容

栈一般用于存放函数参数与局部变量等

函数调用时, 主函数中调用处下一条指令(即函数调用语句下一条可执行语句)地址第一个进栈是, 然后是函数各参数

大多数 C 编译器中, 参数是由右往左入栈, 最后是函数中局部变量(注意 static 变量是不入栈)

当本次函数调用结束后, 遵循先进后出规则, 局部变量先出栈, 然后是参数, 最后栈顶指针指向最开始保存地址, 也就是主函数中下一条指令, 程序由该点继续运行

```c
void Func(int i) {
    printf("%d, %d, %d, %d\n", i, i++, i++, i++);
}

int main(void) {
    int i = 1;
    Func(i);
    return 0;
}
```

由于栈"先进后出"规则, 输出结果是"4, 3, 2, 1"

堆具体存储内容由程序员根据需要决定

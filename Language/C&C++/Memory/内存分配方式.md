<!--
 * @Description: 
 * @Version: 1.0
 * @Author: dmjcb
 * @Email:  
 * @Date: 2021-02-11 21:50:35
 * @LastEditors: dmjcb
 * @LastEditTime: 2024-08-23 20:43:37
-->

# 内存分配

## 分配方式

### 静态存储区域分配

由编译器自动分配和释放, 在程序编译的时已分配好

在程序整个运行期间都存在, 直到整个程序运行结束时才被释放

如全局变量与static变量

### 栈分配

内存中栈区主要用于分配局部变量空间, 由编译器自动分配和释放, 处于相对较高的地址, 栈地址向`低地址`方向增长

在执行函数时函数内局部变量的存储单元都可以在栈上创建, 函数执行结束时这些存储单元将被自动释放

栈内存分配运算内置于处理器的指令集中, 其运行效率一般很高, 但是分配的内存容量有限

### 堆分配

内存中堆区则主要用于分配程序员申请的内存空间, 堆地址向`高地址`方向增长

运行时使用内存分配函数来申请任意内存, 使用完后再使用内存释放函数来释放内存

动态内存的整个生存期由程序员决定, 若在堆上分配了内存空间, 必须及时释放, 否则将会出现内存泄漏等错误

#### malloc

```c
void *malloc(size_t size);
```

malloc 用于从堆中分配内存

| 参数   | 说明                                                                           |
| ------ | ----------------------------------------------------------------------------- |
| size_t | 申请的空间字节数<br>成功会返回该内存空间的地址(不会自动进行初始化)<br>失败返回 NULL |
| void * | 该函数返回类型不确定, 通过接收的指针变量从而进行类型转换                           |

分配内存时需注意, 即使在程序关闭时系统会自动回收该手动申请的内存, 也要进行手动的释放, 以保证内存能够在不需要时返回至堆空间, 使内存能够合理的分配使用

#### free

```c
void free(void *ptr);
```

free用于从堆中释放内存, 释放需将指针指向NULL, 否则会出现野指针

```c
#include<stdio.h>
#include<malloc.h>

int main(void){
    char *p1 = (char *)malloc(sizeof(char));
    char *p2 = (char *)malloc(sizeof(char));

    // p1 = 0x4448928
    printf("p1 = 0x%x\n", p1);
    // p2 = 0x4448960
    printf("p2 = 0x%x\n", p2);

    free(p1);
    p1 = NULL;

    free(p2);
    p2 = NULL;
}
```

动态分配的内存位于堆区中, 堆地址向`高地址方向`增长

```c
#include <stdio.h>
#include <malloc.h>

int main(void) {
    const int SIZE = 4;
    int *p = (int *)malloc(SIZE * sizeof(int));
    
    for(int i = 0; i < SIZE; i++) {
        p[i] = i;
    }

    for(int i = 0; i < SIZE; i++) {
        printf("%d ", p[i]);
    }

    free(p);
    p = NULL;
}
```

## 对比

### 碎片

频繁分配和释放不同大小的堆空间会造成内存空间的不连续, 产生大量碎片, 导致程序效率降低

栈不存在这个问题

### 效率

- 栈

栈是机器系统提供的数据结构, 计算机在底层对栈提供支持

如分配专门的寄存器存放栈的地址, 压栈出栈都有专门的执行指令, 所以栈的效率较高

一般而言, 只要栈的剩余空间大于所申请空间, 系统就将为程序提供内存, 否则将报异常提示栈溢出

- 堆

堆是由 C/C++ 函数库提供, 为分配一块堆内存, 操作系统有一个记录空闲内存地址的链表

当系统收到程序申请时会遍历该链表, 寻找第一个空间大于所申请空间的堆节点, 然后将该节点从空闲节点链表中删除, 并将该节点的空间分配给程序

对于大多数系统, 会在这块内存空间的首地址处记录本次分配的大小, 这样 delete 语句才能正确释放本内存空间

另外, 由于找到的堆节点的大小不一定正好等于申请的大小, 系统会自动将多余的那部分重新放入空闲链表中, 堆的分配效率比栈要低得多

### 申请大小限制

栈是一块连续的内存区域

地址的增长方向向下(内存地址减小的方向)进行, 栈顶的地址和栈的最大容量一般由系统预先规定好, 如果申请的空间超过栈的剩余空间时, 会提示溢出错误

相对于堆, 能够从栈中获得的空间相对较小

操作系统用链表来存储空闲内存地址(内存区域不连续), 链表的遍历方向由低地址向高地址进行

因此, 堆内存的申请大小受限于计算机系统中有效的虚拟内存

### 存储的内容

栈一般用于存放函数参数与局部变量等

函数调用时, 第一个进栈的是主函数中调用处的下一条指令(即函数调用语句的下一条可执行语句)的地址, 然后是函数的各个参数, 在大多数 C 编译器中, 参数是由右往左入栈的, 最后是函数中的局部变量(注意 static 变量是不入栈的)

当本次函数调用结束后, 遵循先进后出的规则, 局部变量先出栈, 然后是参数, 最后栈顶指针指向最开始保存的地址, 也就是主函数中的下一条指令, 程序由该点继续运行

```c
void f(int i) {
    printf("%d, %d, %d, %d\n", i, i++, i++, i++);
}

int main(void) {
    int i = 1;
    f(i);
    return 0;
}
```

由于栈的"先进后出"规则, 所以程序最后的输出结果是"4, 3, 2, 1"

堆具体存储内容由程序员根据需要决定

<!--
 * @Description: 
 * @Version: 1.0
 * @Author: dmjcb
 * @Email:  
 * @Date: 2022-09-29 23:05:52
 * @LastEditors: dmjcb
 * @LastEditTime: 2024-07-31 01:09:28
-->

# new与malloc区别

> [C++ 中 malloc 和 new 的区别](https://murphypei.github.io/blog/2021/03/malloc-new-diff.html)

## 申请内存位置不同

- malloc

从堆上动态分配内存

- new

操作符从自由存储区($free store$)上为对象动态分配内存空间

自由存储区是 C++ 基于 new 操作符的一个抽象概念, 凡是通过 new 操作符进行内存申请,该内存即为自由存储区

自由存储区不仅可以是堆, 还可以是静态存储区, 取决于 operator new 在哪里为对象分配内存


## 返回类型安全性

- new 

操作符内存分配成功时, 返回的是对象类型的指针

类型严格与对象匹配, 无须进行类型转换, 故 new 是符合类型安全性的操作符

- malloc

内存分配成功则是返回 void 指针, 需要通过强制类型转换将 void 指针转换成需要的类型

## 内存分配失败时返回值

- new

内存分配失败时, 会抛出 bac_alloc 异常, 不会返回 NULL

- malloc

分配失败时返回 NULL

## 分配内存大小

- new

操作符申请内存分配时无须指定内存块的大小, 编译器会根据类型信息自行计算

- malloc

则需要明确指出所需内存的尺寸

## 是否调用构造/析构函数

- new

操作符来分配对象内存时会经历三个步骤

(1) 调用 operator new 函数(对于数组是 operator new[])分配一块足够大,原始,未命名的内存空间, 存储特定类型的对象

(2) 编译器运行相应的构造函数以构造对象,并为其传入初值

(3) 对象构造完成后,返回一个指向该对象的指针

delete 操作符来释放对象内存时会经历两个步骤

(1) 调用对象的析构函数

(2) 编译器调用operator delete(或operator delete[])函数释放内存空间

- malloc

不会调用构造函数, free也不会调用析构函数

## 对于数组处理

- new 对数组会分别调用构造函数函数初始化每一个数组元素

C++ 提供new[] 与 delete[] 来专门处理数组类型的分配

释放对象时为每个对象调用析构函数

delete[] 要与 new[] 配套使用,不然会找出数组对象部分释放的现象, 造成内存泄漏

- malloc

只提供开辟出的内存的地址

若动态分配一个数组的内存,还需要手动自定数组大小

## 是否支持内存扩充

- new

不支持内存扩充

- malloc

在分配内存后若内存不足, 可使用 realloc 进行内存重新分配, 实现扩充
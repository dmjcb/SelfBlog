<!--
 * @Brief        : 
 * @Author       : dmjcb
 * @Date         : 2022-02-20 18:19:47
 * @LastEditors  : dmjcb@outlook.com
 * @LastEditTime : 2024-10-11 23:02:26
-->

# 模板

## 使用

### 函数模板

- 单参数

```c++
template<class T>
T Add(T x, T y) {
    return x + y;
}
```

- 多参数

```c++
template<class T, class V>
void Print(T x, V y) {
    std::cout << x << std::endl;
    std::cout << y << std::endl;
}
```

- 默认参数

```c++
template<class T = uint32_t>
T Sub(T x, T y) {
    return x - y;
}
```

### 结构体模板

```c++
template<class T>
struct Node {
    T data;
    Node<T>* next;
};

template<class T>
void Display(Node<T>*& head, std::vector<T>& value) {
    Node<T>* tail = head;

    for (auto v : value) {
        Node<T>* p = new Node<T>;

        p->data = v;
        p->next = nullptr;

        tail->next = p;
        tail = p;
    }

    Node<T>* p = head->next;
    while (p) {
        std::cout << p->data << " ";
        p = p->next;
    }
    std::cout << std::endl;
}
```

### 类模板

```c++
#include <iostream>

template <class T>
class Composer {
public:
    Composer(T x, T y) {
        mX = x;
        mY = y;
    }

    T GetMax() const {
        return mX > mY ? mX : mY;
    }

    T GetMin() const {
        return mX <  mY ? mX : mY;
    }
    void Display() const {
        std::cout << GetMax() << " " << GetMin() << std::endl;
    }

private:
    T mX;
    T mY;
};
```

## 编译

C++编译器在编译模板时, 并不知道模板会被用来实例化哪些类型, 所以无法生成具体的代码。只有在使用模板的时候(即实例化时), 编译器才知道模板参数的类型, 从而生成具体的实现代码。因此：

因此在分离编译模型下(将模板声明放在.h文件中, 定义放在.cpp文件中), 编译器在处理.h文件时无法看到模板的定义, 也就无法实例化模板。

模板实例化 需要在同一个编译单元中同时看到模板的声明和定义, 才能生成特定类型的实例化代码。

### 声明定义均放在头文件

```c++
// TestTemplate.h
#ifndef TEST_TEMPLATE_H
#define TEST_TEMPLATE_H

#include <iostream>

template <typename T>
class MyTemplate {
public:
    void print(const T& value);
};

template <typename T>
void MyTemplate<T>::print(const T& value) {
    std::cout << value << std::endl;
}

#endif // TEST_TEMPLATE_H
```

### 将模板定义放在头文件中的内联实现文件(.hxx\.tpp)

```c++
// TestTemplate.h
#ifndef TEST_TEMPLATE_H
#define TEST_TEMPLATE_H

template <typename T>
class MyTemplate {
public:
    void print(const T& value);
};

#include "TestTemplate.tpp" // 包含模板定义

#endif // TEST_TEMPLATE_H
```

```c++
// TestTemplate.tpp
#include <iostream>

template <typename T>
void MyTemplate<T>::print(const T& value) {
    std::cout << value << std::endl;
}
```

这样可以在.h文件中保持模板声明的简洁性, 同时将模板实现放在另一个文件中, 便于管理

### 显式实例化

如果确定模板只会用于特定类型, 则可以使用显式实例化, 将模板定义放在.cpp文件中, 并在其中实例化需要的类型。

```c++
// TestTemplate.h
#ifndef TEST_TEMPLATE_H
#define TEST_TEMPLATE_H

template <typename T>
class MyTemplate {
public:
    void print(const T& value);
};

#endif
```

```c++
// TestTemplate.cpp
#include "my_template.h"
#include <iostream>

template <typename T>
void MyTemplate<T>::print(const T& value) {
    std::cout << value << std::endl;
}

// 显式实例化
template class MyTemplate<int>;
template class MyTemplate<double>;
```

通过这种方法, .cpp 文件只会生成特定类型的模板实例

对于没有实例化的类型, 编译器会报错
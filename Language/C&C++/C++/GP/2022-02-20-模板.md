---
title: "C++-模板"
date: 2022-02-20
categories: [C&C++]
tags: [C&C++]
excerpt: "模板"
---

# 模板

## 使用

### 普通模板

#### 函数模板

```c++
// 单参数
template<class T>
T Add(T x, T y) {
    return x + y;
}

// 多参数
template<class T, class V>
void Print(T x, V y) {
    std::cout << x << std::endl;
    std::cout << y << std::endl;
}
```

#### 结构体模板

```c++
template<class T>
struct Node {
    T data;
    Node<T>* next;
};

template<class T>
void Display(Node<T>*& head, std::vector<T>& value) {
    Node<T>* tail = head;

    for (auto v : value) {
        Node<T>* p = new Node<T>;

        p->data = v;
        p->next = nullptr;

        tail->next = p;
        tail = p;
    }

    Node<T>* p = head->next;
    while (p) {
        std::cout << p->data << " ";
        p = p->next;
    }
    std::cout << std::endl;
}
```

#### 类模板

```c++
#include <iostream>

template <class T>
class Composer {
public:
    Composer(T x, T y) {
        mX = x;
        mY = y;
    }

    T GetMax() const {
        return mX > mY ? mX : mY;
    }

    T GetMin() const {
        return mX <  mY ? mX : mY;
    }
    void Display() const {
        std::cout << GetMax() << " " << GetMin() << std::endl;
    }

private:
    T mX;
    T mY;
};
```

### 可变参数模板

C++11 标准对模板的功能进行扩展, 允许模板中包含任意数量的模板参数, 称可变参数模板

```c++
template<typename... T>
void VairFun(T...args) {
    // ...
}
```

typename(或者 class)后跟 `...` 就表明 T 是一个可变模板参数, 可以接收多种数据类型, 又称模板参数包

VairFun() 函数中 args 参数的类型用 `T...` 表示, 表示 args 参数可以接收任意个参数

最终实例化出的 VairFun() 函数可以指定任意类型、任意数量的参数

```c
VairFun();

VairFun(1, "abc");

VairFun(1, "abc", 1.23);
```

使用可变参数模板的难点在于, 如何在模板函数内部"解开"参数包(使用包内的数据)

#### 递归方式解包

```c++
#include <iostream>

// 模板函数递归的出口
void VairFun() {
    // ...
}

template <typename T, typename... Args>
void VairFun(T argc, Args... argv) {
    std::cout << argc << std::endl;

    // 开始递归, 将第一个参数外的 argv 参数包重新传递给 VairFun
    VairFun(argv...);
}

int main() {
    VairFun(1, "HelloWorld", 2.34);
    return 0;
}
```

- 执行流程

main() 函数调用 VairFun() 模板函数时, 根据所传实参的值, 可以很轻易地判断出模板参数 T 的类型为 int

函数参数 argc 的值为 1, 剩余的模板参数和函数参数都分别位于 args 和 argv 中

VairFun() 函数中, 首先输出了 argc 的值(为 1), 然后重复调用自身, 同时将函数参数包 argv 中的数据作为实参传递给形参 argc 和 argv;

再次执行 VairFun() 函数, 此时模板参数 T 的类型为 char*, 输出 argc 的值为 "http:www.biancheng.net"再次调用自身, 继续将 argv 包中的数据作为实参

再次执行 VairFun() 函数, 此时模板参数 T 的类型为 double, 输出 argc 的值为 2.34再次调用自身, 将空的 argv 包作为实参

由于 argv 包没有数据, 此时会调用无任何形参、函数体为空的 VairFun() 函数, 最终执行结束

以递归方式解包一定要设置递归结束的出口如本例中, 无形参、函数体为空的 VairFun() 函数就是递归结束的出口

#### 非递归方法解包

借助逗号表达式和初始化列表解包

```c++
#include <iostream>

template <typename T>
void Dispaly(T value) {
    std::cout << value << std::endl;
}

template <typename... Args>
void VairFun(Args... argv) {
    // 逗号表达式与初始化列表的方式对数组进行了初始化
    // 等价 int arr[] = { (dispaly(1),0), (dispaly("HelloWorld"),0), (dispaly(2.34),0) };
    int arr[] = { (Dispaly(argv), 0)... };
}

int main(void) {
    VairFun(1, "HelloWorld", 2.34);
    return 0;
}
```

每个元素都是一个逗号表达式, 以 (display(1), 0) 为例, 它会先计算 display(1), 然后将 0 作为整个表达式的值返回给数组, 因此 arr 数组最终存储的都是 0

arr 数组纯粹是为了将参数包展开, 没有发挥其它作用

## 特征

### 模板特化

模板特化允许为特定类型提供不同的实现。有两种类型的模板特化：全特化和偏特化。

#### 全特化(Explicit Specialization)

全特化是对模板的所有参数提供特定实现, 在这种情况下, 模板特化的类型必须完全匹配。

```c++
#include <iostream>
#include <string>

template<typename T>
struct Printer {
    void print(const T& value) {
        std::cout << "General template: " << value << std::endl;
    }
};

// 针对 std::string 类型的全特化
template<>
struct Printer<std::string> {
    void print(const std::string& value) {
        std::cout << "String specialization: " << value << std::endl;
    }
};

int main() {
    Printer<int> intPrinter;
    // General template: 42
    intPrinter.print(42);

    Printer<std::string> stringPrinter;
    // String specialization: Hello, World!
    stringPrinter.print("Hello, World!");

    return 0;
}
```

Printer模板对std::string类型进行了全特化

一般情况下, Printer模板会打印"General template: "前缀, 但在特化版本(即std::string), 则打印"String specialization: "前缀

#### 偏特化(Partial Specialization)

偏特化允许特化模板的一部分参数, 而不是全部参数, 通常适用于类模板

```c++
#include <iostream>
#include <vector>

template<typename T, typename Allocator = std::allocator<T>>
struct Container {
    void print() {
        std::cout << "General container" << std::endl;
    }
};

// 偏特化, 当 T 是 std::vector 类型时
template<typename T, typename Allocator>
struct Container<std::vector<T, Allocator>, Allocator> {
    void print() {
        std::cout << "Vector container" << std::endl;
    }
};

int main() {
    Container<int> intContainer;
    // General container
    intContainer.print();

    Container<std::vector<int>> vectorContainer;
    // Vector container
    vectorContainer.print();

    return 0;
}
```

在这里, Container模板对模板参数T是std::vector的情况进行了偏特化

普通类型使用一般的print, 而std::vector则使用偏特化的版本。

### 基于类型模板

提取模板变量的类型及其特性主要通过类型萃取(Type Traits)和SFINAE(Substitution Failure Is Not An Error)技术来实现

利用标准库中的头文件 <type_traits>, 可以方便地检查、提取和操作模板变量的类型信息

#### std::decay

std::decay 用于提取模板变量的"衰减类型", 它会去掉引用、const、volatile修饰符, 并将数组和函数类型转换为指针类型

```c++
#include <iostream>
#include <type_traits>

template <typename T>
void PrintDecayedType() {
    using DecayedType = typename std::decay<T>::type;
    std::cout << typeid(DecayedType).name() << std::endl;
}

int main() {
    PrintDecayedType<int&>();       

    PrintDecayedType<const int[]>();
}
```

### std::remove_reference 和 std::remove_cv 提取

```c++
#include <iostream>
#include <type_traits>

template <typename T>
void PrintStrippedType() {
    using NoRefType = typename std::remove_reference<T>::type;
    using NoCVType = typename std::remove_cv<NoRefType>::type;

    std::cout << typeid(NoCVType).name() << std::endl;
}

int main() {
    PrintStrippedType<const int&>();
}
```

#### std::is_* 系列萃取

```c++
#include <iostream>
#include <type_traits>

template <typename T>
void PrintTypeTraits() {
    if (std::is_pointer<T>::value) {
        std::cout << "is_pointer: " << std::is_pointer<T>::value << std::endl;
    }

    if (std::is_reference<T>::value) {
        std::cout << "is_reference: " << std::is_reference<T>::value << std::endl;
    }

    if (std::is_integral<T>::value) {
        std::cout << "is_integral: " << std::is_integral<T>::value << std::endl;
    }

    if (std::is_floating_point<T>::value) {
        std::cout << "is_float: " << std::is_floating_point<T>::value << std::endl;
    }
}

int main() {
    PrintTypeTraits<int*>();
    PrintTypeTraits<int&>();
    PrintTypeTraits<float>();
}
```

#### std::underlying_type 获取枚举底层类型

对于枚举类型, std::underlying_type 可以提取其底层的整型类型

```c++
#include <iostream>
#include <type_traits>

enum class MyEnum : char { A, B, C };

template <typename T>
void PrintUnderlyingType() {
    using UnderlyingType = typename std::underlying_type<T>::type;
    std::cout << typeid(UnderlyingType).name() << std::endl;
}

int main() {
    PrintUnderlyingType<MyEnum>();
}
```

###  decltype 提取表达式类型

```c++
template <typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}

int main() {
    // 推导出result类型为double
    auto result = add(1, 2.0);
    // 输出: double
    std::cout << typeid(result).name() << std::endl; 
}
```

## 编译

C++编译器在编译模板时, 并不知道模板会被用来实例化哪些类型, 所以无法生成具体的代码, 只有在使用模板的时候(即实例化时), 编译器才知道模板参数的类型, 从而生成具体的实现代码

因此在分离编译模型下(将模板声明放在.h文件中, 定义放在.cpp文件中), 编译器在处理.h文件时无法看到模板的定义, 也就无法实例化模板

模板实例化 需要在同一个编译单元中同时看到模板的声明和定义, 才能生成特定类型的实例化代码

### 声明定义均放在头文件

- TestTemplate.hpp

```c++
#ifndef TEST_TEMPLATE_HPP
#define TEST_TEMPLATE_HPP

#include <iostream>

template <typename T>
class MyTemplate {
public:
    void print(const T& value);
};

template <typename T>
void MyTemplate<T>::print(const T& value) {
    std::cout << value << std::endl;
}

#endif
```

### 模板定义放在头文件中的内联实现文件(.hxx\.tpp)

- TestTemplate.hpp

```c++
#ifndef TEST_TEMPLATE_HPP
#define TEST_TEMPLATE_HPP

template <typename T>
class MyTemplate {
public:
    void print(const T& value);
};

// 包含模板定义
#include "TestTemplate.tpp"

#endif
```

- TestTemplate.tpp

```c++
#include <iostream>

template <typename T>
void MyTemplate<T>::print(const T& value) {
    std::cout << value << std::endl;
}
```

这样可以在.h文件中保持模板声明的简洁性, 同时将模板实现放在另一个文件中, 便于管理

### 显式实例化

如果确定模板只会用于特定类型, 则可以使用显式实例化, 将模板定义放在.cpp文件中, 并在其中实例化需要的类型

- TestTemplate.hpp

```c++
#ifndef TEST_TEMPLATE_HPP
#define TEST_TEMPLATE_HPP

#include <iostream>

template <typename T>
class MyTemplate {
public:
    void print(const T& value);
};

#endif
```

- TestTemplate.cpp

```c++
#include "TestTemplate.hpp"

template <typename T>
void MyTemplate<T>::print(const T& value) {
    std::cout << value << std::endl;
}

// 显式实例化
template class MyTemplate<int>;
template class MyTemplate<double>;
```

通过这种方法, .cpp 文件只会生成特定类型的模板实例, 对于没有实例化的类型, 编译器会报错
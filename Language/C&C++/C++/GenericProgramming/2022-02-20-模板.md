---
title: "模板"
date: 2022-02-20
categories: [C&C++]
tags: [C&C++]
excerpt: "模板"
---

# 模板

## 使用

### 函数模板

- 单参数

```c++
template<class T>
T Add(T x, T y) {
    return x + y;
}
```

- 多参数

```c++
template<class T, class V>
void Print(T x, V y) {
    std::cout << x << std::endl;
    std::cout << y << std::endl;
}
```

- 默认参数

```c++
template<class T = uint32_t>
T Sub(T x, T y) {
    return x - y;
}
```

### 结构体模板

```c++
template<class T>
struct Node {
    T data;
    Node<T>* next;
};

template<class T>
void Display(Node<T>*& head, std::vector<T>& value) {
    Node<T>* tail = head;

    for (auto v : value) {
        Node<T>* p = new Node<T>;

        p->data = v;
        p->next = nullptr;

        tail->next = p;
        tail = p;
    }

    Node<T>* p = head->next;
    while (p) {
        std::cout << p->data << " ";
        p = p->next;
    }
    std::cout << std::endl;
}
```

### 类模板

```c++
#include <iostream>

template <class T>
class Composer {
public:
    Composer(T x, T y) {
        mX = x;
        mY = y;
    }

    T GetMax() const {
        return mX > mY ? mX : mY;
    }

    T GetMin() const {
        return mX <  mY ? mX : mY;
    }
    void Display() const {
        std::cout << GetMax() << " " << GetMin() << std::endl;
    }

private:
    T mX;
    T mY;
};
```

## 特征

### 模板特化

模板特化允许为特定类型提供不同的实现。有两种类型的模板特化：全特化和偏特化。

#### 全特化(Explicit Specialization)

全特化是对模板的所有参数提供特定实现, 在这种情况下, 模板特化的类型必须完全匹配。

```c++
#include <iostream>
#include <string>

template<typename T>
struct Printer {
    void print(const T& value) {
        std::cout << "General template: " << value << std::endl;
    }
};

// 针对 std::string 类型的全特化
template<>
struct Printer<std::string> {
    void print(const std::string& value) {
        std::cout << "String specialization: " << value << std::endl;
    }
};

int main() {
    Printer<int> intPrinter;
    // General template: 42
    intPrinter.print(42);

    Printer<std::string> stringPrinter;
    // String specialization: Hello, World!
    stringPrinter.print("Hello, World!");

    return 0;
}
```

Printer模板对std::string类型进行了全特化

一般情况下, Printer模板会打印"General template: "前缀, 但在特化版本(即std::string), 则打印"String specialization: "前缀

#### 偏特化(Partial Specialization)

偏特化允许特化模板的一部分参数, 而不是全部参数, 通常适用于类模板

```c++
#include <iostream>
#include <vector>

template<typename T, typename Allocator = std::allocator<T>>
struct Container {
    void print() {
        std::cout << "General container" << std::endl;
    }
};

// 偏特化, 当 T 是 std::vector 类型时
template<typename T, typename Allocator>
struct Container<std::vector<T, Allocator>, Allocator> {
    void print() {
        std::cout << "Vector container" << std::endl;
    }
};

int main() {
    Container<int> intContainer;
    // General container
    intContainer.print();

    Container<std::vector<int>> vectorContainer;
    // Vector container
    vectorContainer.print();

    return 0;
}
```

在这里, Container模板对模板参数T是std::vector的情况进行了偏特化

普通类型使用一般的print, 而std::vector则使用偏特化的版本。

### 基于类型模板

提取模板变量的类型及其特性主要通过类型萃取(Type Traits)和SFINAE(Substitution Failure Is Not An Error)技术来实现

利用标准库中的头文件 <type_traits>, 可以方便地检查、提取和操作模板变量的类型信息

#### std::decay

std::decay 用于提取模板变量的"衰减类型", 它会去掉引用、const、volatile修饰符, 并将数组和函数类型转换为指针类型

```c++
#include <iostream>
#include <type_traits>

template <typename T>
void PrintDecayedType() {
    using DecayedType = typename std::decay<T>::type;
    std::cout << typeid(DecayedType).name() << std::endl;
}

int main() {
    PrintDecayedType<int&>();       

    PrintDecayedType<const int[]>();
}
```

### std::remove_reference 和 std::remove_cv 提取

```c++
#include <iostream>
#include <type_traits>

template <typename T>
void PrintStrippedType() {
    using NoRefType = typename std::remove_reference<T>::type;
    using NoCVType = typename std::remove_cv<NoRefType>::type;

    std::cout << typeid(NoCVType).name() << std::endl;
}

int main() {
    PrintStrippedType<const int&>();
}
```

#### std::is_* 系列萃取

```c++
#include <iostream>
#include <type_traits>

template <typename T>
void PrintTypeTraits() {
    if (std::is_pointer<T>::value) {
        std::cout << "is_pointer: " << std::is_pointer<T>::value << std::endl;
    }

    if (std::is_reference<T>::value) {
        std::cout << "is_reference: " << std::is_reference<T>::value << std::endl;
    }

    if (std::is_integral<T>::value) {
        std::cout << "is_integral: " << std::is_integral<T>::value << std::endl;
    }

    if (std::is_floating_point<T>::value) {
        std::cout << "is_float: " << std::is_floating_point<T>::value << std::endl;
    }
}

int main() {
    PrintTypeTraits<int*>();
    PrintTypeTraits<int&>();
    PrintTypeTraits<float>();
}
```

#### std::underlying_type 获取枚举底层类型

对于枚举类型, std::underlying_type 可以提取其底层的整型类型

```c++
#include <iostream>
#include <type_traits>

enum class MyEnum : char { A, B, C };

template <typename T>
void PrintUnderlyingType() {
    using UnderlyingType = typename std::underlying_type<T>::type;
    std::cout << typeid(UnderlyingType).name() << std::endl;
}

int main() {
    PrintUnderlyingType<MyEnum>();
}
```

###  decltype 提取表达式类型

```c++
template <typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}

int main() {
    // 推导出result类型为double
    auto result = add(1, 2.0);
    // 输出: double
    std::cout << typeid(result).name() << std::endl; 
}
```

## 编译

C++编译器在编译模板时, 并不知道模板会被用来实例化哪些类型, 所以无法生成具体的代码, 只有在使用模板的时候(即实例化时), 编译器才知道模板参数的类型, 从而生成具体的实现代码

因此在分离编译模型下(将模板声明放在.h文件中, 定义放在.cpp文件中), 编译器在处理.h文件时无法看到模板的定义, 也就无法实例化模板

模板实例化 需要在同一个编译单元中同时看到模板的声明和定义, 才能生成特定类型的实例化代码

### 声明定义均放在头文件

- TestTemplate.hpp

```c++
#ifndef TEST_TEMPLATE_HPP
#define TEST_TEMPLATE_HPP

#include <iostream>

template <typename T>
class MyTemplate {
public:
    void print(const T& value);
};

template <typename T>
void MyTemplate<T>::print(const T& value) {
    std::cout << value << std::endl;
}

#endif
```

### 模板定义放在头文件中的内联实现文件(.hxx\.tpp)

- TestTemplate.hpp

```c++
#ifndef TEST_TEMPLATE_HPP
#define TEST_TEMPLATE_HPP

template <typename T>
class MyTemplate {
public:
    void print(const T& value);
};

// 包含模板定义
#include "TestTemplate.tpp"

#endif
```

- TestTemplate.tpp

```c++
#include <iostream>

template <typename T>
void MyTemplate<T>::print(const T& value) {
    std::cout << value << std::endl;
}
```

这样可以在.h文件中保持模板声明的简洁性, 同时将模板实现放在另一个文件中, 便于管理

### 显式实例化

如果确定模板只会用于特定类型, 则可以使用显式实例化, 将模板定义放在.cpp文件中, 并在其中实例化需要的类型

- TestTemplate.hpp

```c++
#ifndef TEST_TEMPLATE_HPP
#define TEST_TEMPLATE_HPP

#include <iostream>

template <typename T>
class MyTemplate {
public:
    void print(const T& value);
};

#endif
```

- TestTemplate.cpp

```c++
#include "TestTemplate.hpp"

template <typename T>
void MyTemplate<T>::print(const T& value) {
    std::cout << value << std::endl;
}

// 显式实例化
template class MyTemplate<int>;
template class MyTemplate<double>;
```

通过这种方法, .cpp 文件只会生成特定类型的模板实例, 对于没有实例化的类型, 编译器会报错
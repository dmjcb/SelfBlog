---
title: "操作系统-内核"
date: 2021-11-06
categories: [内核]
tags: [操作系统]
excerpt: "内核"
---

# 内核

> - [NASM汇编初探(入门教程)](https://blog.csdn.net/qq_52300431/article/details/127397862)
> - [搭建i386交叉编译环境](https://github.com/lordmilko/i686-elf-tools)

## 程序

```asm
section .data
    msg db 'Hello World!', 0AH     ; 初始化变量msg
 
section .text
    global  _start
 
_start:
    mov	edx, 13     ; 待写入的字节数(每个字母一个字节, 再加上换行符0Ah)
    mov ecx, msg    ; 将msg的内存地址移入ecx
    mov ebx, 1      ; 表示写入到标准输出STDOUT
    mov eax, 4      ; 调用SYS_WRITE(OPCODE是4)
    int 0x80

    mov ebx, 0
    mov eax, 1
    int 0x80
```

此时生成的32位目标文件

```sh
nasm -f elf Hello.asm
```

- 链接

```sh
ld -m elf_i386 Hello.o -o Hello

或

gcc -m32 -c Hello.o -o Hello
```

## 引导程序

```asm
; boot.asm
BITS 16              ; 16-bit real mode
ORG 0x7C00           ; The BIOS loads bootloader at memory address 0x7C00

start:
    mov ax, 0x07C0   ; Set segment registers
    mov ds, ax
    mov es, ax

    ; Print message
    mov si, welcome_msg
    call print_string

    ; Load kernel (we assume kernel starts at sector 2)
    mov bx, 0x1000   ; Load kernel to address 0x1000
    mov dh, 1        ; We will load 1 sector for simplicity
    call load_kernel

    ; Jump to the loaded kernel (0x1000 offset 0)
    jmp 0x1000:0x0000

; Function to print string (terminated by 0)
print_string:
    mov ah, 0x0E
.next_char:
    lodsb
    cmp al, 0
    je .done
    int 0x10
    jmp .next_char
.done:
    ret

; Function to load kernel from disk
load_kernel:
    mov ah, 0x02     ; BIOS read sector function
    mov al, dh       ; Number of sectors to read
    mov ch, 0x00     ; Cylinder 0
    mov cl, 0x02     ; Sector 2 (start at sector 2)
    mov dh, 0x00     ; Head 0
    mov dl, 0x80     ; Drive 0x80 (first hard drive)
    int 0x13
    jc load_failed
    ret

load_failed:
    hlt

welcome_msg db "Welcome to MyOS!", 0

TIMES 510 - ($ - $$) db 0
DW 0xAA55           ; Boot signature
```

```sh
nasm -f bin src/boot.asm -o boot.bin
```

## 编写内核

```c
// kernel.c
void kernel_main() {
    // Video memory starts at 0xB8000 for text mode
    char *video_memory = (char *)0xB8000;
    
    // Display a simple message
    const char *message = "Hello, MyOS!";
    int i = 0;
    
    // Each character is 2 bytes in video memory: 1 byte character, 1 byte attribute
    while (message[i] != '\0') {
        video_memory[i * 2] = message[i];        // Character
        video_memory[i * 2 + 1] = 0x07;          // Attribute byte: light grey on black
        i++;
    }
}
```

```sh
i386-elf-gcc -ffreestanding -m32 -c kernel.c -o kernel.o

i386-elf-ld -o kernel.bin -Ttext 0x1000 --oformat binary kernel.o
```

## 链接

```sh
cat boot.bin kernel.bin > 操作系统-image.bin
```
---
title: "cmake语法"
date: 2024-10-22
categories: [cmake]
tags: [cmake]
excerpt: "cmake语法"
---

## 设置

### cmake最低版本

```cmake
cmake_minimum_required(VERSION major.minor)
```

```mermaid
graph LR
    P(参数)
    P-->A(VERSION)-->A1(关键字, 表示所需CMake 版本号)
    P-->B(major)-->B1(主版本号)
    P-->C(minor)-->C1(次版本号)
```

- 示例, 设置工程最低cmake版本为3.10

```cmake
cmake_minimum_required(VERSION 3.10)
...
```

### 项目名

```cmake
project(项目名 (VERSION 版本信息, 可选))
```

- 示例, 设置项目名为main

```cmake
cmake_minimum_required(VERSION 3.10)
project(main)
...
```

### 变量

```cmake
set(variable value [PARENT_SCOPE])
```

```mermaid
graph LR
    P(参数)
    P-->A(variable)-->A1(变量名, 通常由大写字母组成, 以区别于cmake内置变量和函数)
    P-->B(value)-->B1(变量值, 可以是字符串、列表或其他cmake变量)
    P-->C(PARENT_SCOPE, 可选)-->C1(如果指定, 变量将在父作用域中设置)
```

#### 设置

##### 一般变量

- 示例, 设置变量MY_VAR

```cmake
set(MY_VAR "Hello, World!")
```

##### 列表变量

- 示例, 设置SRC_LIST存储源文件名

```cmake
set(SRC_LIST main.cpp test.cpp)
```

```cmake
set(MY_LIST "item1" "item2" "item3")

foreach(item IN LISTS MY_LIST)
    message(STATUS "List item: ${item}")
endforeach()
```

#### 父作用域中设置

- 示例, 父作用域设置变量

```cmake
function(my_func)
    set(MY_VAR_INSIDE "inside function" PARENT_SCOPE)
endfunction()

my_func()
message(STATUS "The value of MY_VAR_INSIDE after function call is: ${MY_VAR_INSIDE}")
```

my_func 函数内指定 PARENT_SCOPE 选项在父作用域中设置 MY_VAR_INSIDE 变量

即使在函数调用之后, MY_VAR_INSIDE 也可以在外部作用域中访问

#### 使用

cmake中通过`${变量名}`获取变量值

- 示例, 使用变量ANOTHER_VAR

```cmake
set(ANOTHER_VAR "Another Value")

set(MY_VAR2 ${ANOTHER_VAR})
```

## 添加

### 头文件目录

指定编译目标(可执行文件或库)应包含头文件目录

```cmake
target_include_directories(
    target
    [SYSTEM]
    [AFTER|BEFORE]
    <PRIVATE|PUBLIC|INTERFACE>
    <directories>
)
```

```mermaid
graph LR
    P(参数)
    P-->A(target)-->A1(目标名称, 表示可执行文件或库)
    P-->B(SYSTEM, 可选)-->B1(告诉编译器包含目录是系统级目录)
    P-->C(AFTER、BEFORE, 可选)-->C1(指定包含目录插入位置)
        C1-->C11(AFTER 表示在现有目录之后)
        C1-->C12(BEFORE 表示在现有目录之前)
    P-->D(INTERFACE PRIVATE PUBLIC)-->D1(指定包含目录作用域)
        D1-->D11(PUBLIC)-->D111(对编译目标本身及其依赖均可见)
        D1-->D12(PRIVATE)-->D121(仅对编译目标本身可见)
        D1-->D13(INTERFACE)-->D131(仅对依赖于该目标其他目标使用)
    P-->E(directories)-->E1(要包含头文件目录列表)
```

- 示例, 为main目标文件添加头文件目录

```sh
.
├── CMakeLists.txt
├── src
│   ├── main.c
│   └── module
│       └── test_api
│           └── include
│               └── test_api.h
└── third_party
    └── hello_lib
        └── hello.h
```

```c++
// third_party/hello_lib/hello.h
#include <stdio.h>

void Hello() {
    printf("Hello OK\n");
}
```

```c++
// src/module/test_api/include/test_api.h
#include <stdio.h>

void Test() {
    printf("Test OK\n");
}
```

```c++
// src/main.c
#include "hello.h"
#include "test_api.h"

int main() {
    Hello();
    Test();
    return 0;
}
```

```cmake
# CMakeLists.txt
cmake_minimum_required(VERSION 3.10)
project(main)

add_executable(main src/main.c)

target_include_directories(
    main
    PRIVATE
    ${CMAKE_SOURCE_DIR}/third_party/hello_lib
    ${CMAKE_SOURCE_DIR}/src/module/test_api/include
)
```

![](/assets/image/20241217_214508.jpg)

### 源文件路径

给目标文件添加依赖源文件路径

```cmake
target_sources(<target> <INTERFACE|PUBLIC|PRIVATE> [items1...])
```

```mermaid
graph LR
    P(参数)
    P-->A(target)-->A1(目标名称)
    P-->D(INTERFACE PRIVATE PUBLIC)-->D1(指定包含源文件可见性)
        D1-->D11(PUBLIC)-->D111(对编译目标及目标依赖均可见)
        D1-->D12(PRIVATE)-->D121(仅对编译目标本身可见)
        D1-->D13(INTERFACE)-->D131(仅对依赖于该目标其他目标使用)
```

- 示例, 添加源文件编译

```sh
.
├── CMakeLists.txt
└── src
    ├── hello
    │   ├── hello.c
    │   └── hello.h
    └── main.c
```

```c
// src/hello/hello.h
#include <stdio.h>

void Hello();
```

```c
// src/hello/hello.c
#include "hello.h"

void Hello() {
    printf("Hello\n");
}
```

```c
// src/main.c
#include "hello/hello.h"

int main() {
    Hello();
    return 0;
}
```

```cmake
# CMakeLists.txt
cmake_minimum_required(VERSION 3.10)
project(main)

add_executable(main "")

target_sources(
    main
    PRIVATE
    ${CMAKE_SOURCE_DIR}/src/main.c
    ${CMAKE_SOURCE_DIR}/src/hello/hello.c
)
```

![](/assets/image/20241217_223229.jpg)

### 链接依赖

指定链接给定目标和/或其依赖项

```cmake
target_link_libraries(target <INTERFACE|PUBLIC|PRIVATE> item...)
```

```mermaid
graph LR
    P(参数)
    P-->A(target)-->A1(目标名称, 可以是可执行文件、共享库或静态库)
    P-->D1(可见性)
        D1-->D11(PUBLIC)-->D111(指定库用于链接目标本身, 并传播给目标依赖项)
        D1-->D12(PRIVATE)-->D121(指定库仅用于链接目标本身, 不传播给目标依赖项)
        D1-->D13(INTERFACE)-->D131(指定库不会用于链接目标本身, 但会传播给目标依赖项)
```

#### 链接系统库

如果项目需要链接系统库, 可以直接使用库名称(如 pthread、dl、m 等)或系统库变量(如 ${CMAKE_THREAD_LIBS_INIT})

- 示例, 链接系统POSIX线程库

```cmake
target_link_libraries(mytarget pthread)

# cmake线程支持模块
target_link_libraries(mytarget ${CMAKE_THREAD_LIBS_INIT})
```

#### 链接自定义库

- 示例, 链接自定义库

```cmake
target_link_libraries(mytarget PRIVATE mylibrary)
target_link_libraries(mytarget PUBLIC ${CMAKE_SOURCE_DIR}/lib/libexample.a)
target_link_libraries(mytarget INTERFACE ${CMAKE_SOURCE_DIR}/lib/libanother.so)
```

## 生成

### 子路径生成

为构建添加一个子路径

```cmake
add_subdirectory([source_dir] [binary_dir] [EXCLUDE_FROM_ALL])
```

```mermaid
graph LR
    P(参数)
    P-->A(source_dir)-->A1(指定源 CMakeLists.txt 和代码文件路径)
    P-->B(binary_dir)-->B1(指定放置输出文路径)
    P-->C(EXCLUDE_FROM_ALL, 可选)-->C1(子目录中目标将不包括在父目录ALL目标中, 用户必须在子目录中显式构建目标)
```

### 库文件

创建库文件, 库名对应于逻辑目标名称, 在工程全局域内必须唯一

```cmake
add_library(target [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1 source2 ...)
```

```mermaid
graph LR
    X(参数)
    X-->A(STATIC)-->A1(目标文件归档文件, 在链接其它目标时使用)
    X-->B(SHARED)-->B1(会被动态链接, 在运行时被加载)
    X-->C(MODULE)-->C1(不会被链接到其它目标中插件, 但可能会在运行时使用dlopen-系列函数动态链)
```

### 可执行文件

```cmake
add_executable(target src_1 ...)
```

## 安装

### 目标文件

#### 可执行文件

```sh
install(TARGETS 文件名 RUNTIME DESTINATION 安装路径)
```

- 示例, 安装可执行文件main到根目录bin/

```c
// main.c
#include <stdio.h>

int main() {
    printf("Hello\n");
    return 0;
}
```

```cmake
# CMakeLists.txt
cmake_minimum_required(VERSION 3.10)
project(main)

add_executable(main main.c)

install(TARGETS main RUNTIME DESTINATION ${CMAKE_SOURCE_DIR}/bin)
```

![](/assets/image/20241217_225908.jpg)

#### 动态库

```cmake
install(TARGETS LIBRARY DESTINATION )
```

#### 静态库

```cmake
install(TARGETS ARCHIVE DESTINATION )
```

### 目录

```cmake
install(DIRECTORY DESTINATION )
```

#### 文件匹配过滤

```cmake
install(DIRECTORY DESTINATION FILES_MATCHING PATTERN )
```

- 示例, 仅安装.h和.hpp

```cmake
install(DIRECTORY ${CMAKE_SOURCE_DIR}/src DESTINATION shared FILES_MATCHING PATTERN "*.h" PATTERN "*.hpp")
```

## 常量

TODO
